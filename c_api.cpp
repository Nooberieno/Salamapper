#include <salamapper/salamapper.h>
#include <salamapper/parse.hpp>
#include <salamapper/print.hpp>
#include <salamapper/rooter.hpp>
#include <salamapper/TreeNode.hpp>
#include <salamapper/top sort.hpp>

#include <string>
#include <cstring>
#include <sstream>
#include <iostream>
#include <vector>

/*!
@struct TreeHandle
@brief A handle for managing a tree structure and its associated graph

This struct contains a pointer to the root of the tree. It also contains the associated graph representation used to construct the tree
*/
struct TreeHandle{
	TreeNode *root;
	std::unordered_map<std::string, std::vector<std::string>> graph;

	~TreeHandle(){delete root;};
};

/*!
@brief Creates a tree from a formatted string and returns a handle to it

This function creates a rooted tree structure from a formatted string by first turning it into a graph and then turning that graph into a rooted tree structure
The graph and pointer to the root of the tree are stored in a TreeHandle struct, a pointer to this TreeHandle will be returned by this function upon succesful completion

@param format_string The string representation of the graph
	The expected format is: 
	"ID1:child1,child2,...;ID2:child1,child2,..;"
	Example: "1:2,3,5;2:3;3:4;4:;5:6,7;6:7;7:;"
@param root_id The id of the node to be used as root node
@param cycle_mode The cycle handling mode (defaults to CYCLE_ERROR)

@par 
	- CYCLE_ERROR: Throws an exception when a cycle is detected.
	- CYCLE_WARN: Prints a warning to stderr and continues, skipping the cyclic edge.
	- CYCLE_IGNORE: Silently ignores cyclic edges and continues.

@return TreeHandle*	A pointer to the created TreeHandle, returns a nullptr if creation fails

@note The caller is responsible for freeing the returned TreeHandle using the ClearTree function
@see TreeHandle
@see ClearTree
*/
TreeHandle* CreateTree(const char* format_string, const char* root_id, enum CycleHandling cycle_mode = CYCLE_ERROR){
	try
	{
		TreeHandle* handle = new TreeHandle();
		handle->graph = Parse(format_string);
		handle->root = RootTree(handle->graph, root_id, cycle_mode);
		return handle;
	}
	catch(const std::exception &e)
	{
		std::cerr << "Error creating tree: " << e.what() << std::endl;
		return nullptr;
	}
	catch(...)
	{
		return nullptr;
	}
}

/*!
@brief Clears a TreeHandle and frees its associated memory

This function takes in a TreeHandle, deconstructs its tree from the root and then frees the root and the graph from memory

@param handle Pointer to the TreeHandle that needs to be cleared
@note This function sets the pointer to the TreeHandle to a nullptr after freeing
*/
void ClearTree(TreeHandle* handle){
	if (handle){
		delete(handle->root);
		handle->root = nullptr;
		delete(handle);
		handle = nullptr;
	}
}

/*!
@brief Generates a string representation of the rooted tree structure

This function takes in a TreeHandle and returns a string with an ASCII art style representation of the structure of the rooted tree

@param handle Pointer to the TreeHandle containing the tree

@return char* A string containing the tree representation on success, returns nullptr on failure

@par ASCII Art Representation:
	- Root nodes are printed without any prefix.
	- Non-root nodes use "└─" if they are the last child, or "├─" otherwise.
	- Vertical lines (│) are used to connect siblings visually.

@warning This function assumes that the TreeNode structure has been properly initialized and that circulair references do not exist in the tree

Example output:
@code
Root
├─Child1
│  ├─GrandChild1
│  └─GrandChild2
└─Child2
   └─GrandChild3
@endcode

@note The caller is responsible for freeing the returned string, possibly using the FreeString function
@see FreeString
*/
char* GetTree(TreeHandle* handle){
	if (!handle || !handle->root) return nullptr;

	try
	{
		std::string prefix;
		std::stringstream ss;
		std::streambuf* old = std::cout.rdbuf(ss.rdbuf());
		PrintTree(handle->root, prefix, true, true);
		std::cout.rdbuf(old);
		std::string result = ss.str();
		char* c_str = new char[result.length() + 1];
		strcpy(c_str, result.c_str());
		return c_str;
	}
	catch(...)
	{
		return nullptr;
	}
}

/*!
@brief Frees a string

Frees the memory of an allocated string, to be used on strings generated by the GetTree or TopSort functions
@param str Pointer to the string to be freed
@see GetTree
@see TopSortKahnHandle
@see TopSortKahnString
*/
void FreeString(char* str){
	delete[] str;
}

/*!
@brief Performs a topological sort on the graph in a TreeHandle using Kahn's algorithm

Gets the topological order of the graph in a TreeHandle by performing topological sort on it using Kahn's algorithm

@param handle Pointer to the TreeHandle containing the graph

@return char* A string containing the topological order with each id seperated by comma's

@note This function is specifically designed to be used hand in hand with other tree operations, for topological sorting without first creating a tree structure see TopSortKahnString
@see TopSortKahnString

@note This function returns the topological order in a sink to source method, meaning that in the case of a rooted tree graph, the root comes last in the ordering rather then first
	Example: 
	@code
	Root
	├─Child1
	│  ├─GrandChild1
	│  └─GrandChild2
	└─Child2
	   └─GrandChild3
	@endcode
	returns Grandchild3 Child2 GrandChild2 GrandChild1 Child1 Root

@note The caller is responsible for freeing the returned string, possibly by using FreeString
@see FreeString
*/
char* TopSortKahnHandle(const TreeHandle* handle){
	try
	{
		std::vector<std::string> TopOrder = KahnTopSort(handle->graph);
		std::string result_str;
		for (size_t i = 0; i < TopOrder.size(); i++){
			result_str += TopOrder[i];
			if (i < TopOrder.size() -1) result_str += ",";
		}
		char* result = new char[result_str.length() + 1];
		strcpy(result, result_str.c_str());
		return result;
	}
	catch(const std::exception& e)
	{
		std::cerr << e.what() << std::endl;
		return nullptr;
	}
}

/*!
@brief Performs a topological sort on a graph represented as a formatted string using Kahn's algorithm

Gets the topological order of a graph represented by a formatted string by performing topological sort on it using Kahn's algorithm

@param format_string The string representation of the graph
	The expected format is: 
	"ID1:child1,child2,...;ID2:child1,child2,..;"
	Example: "1:2,3,5;2:3;3:4;4:;5:6,7;6:7;7:;"

@return char* A string containing the topological order with each id seperated by comma's

@note This function is designed as a faster way to achieve topological order for those who do not need tree operations or a TreeHandle, if these are desired see TopSortKahnHandle
@see TopSortKahnHandle

@note This function returns the topological order in a sink to source method, meaning that in the case of a rooted tree graph, the root comes last in the ordering rather then first
	Example: 
	@code
	Root
	├─Child1
	│  ├─GrandChild1
	│  └─GrandChild2
	└─Child2
	   └─GrandChild3
	@endcode
	returns Grandchild3,Child2,GrandChild2,GrandChild1,Child1,Root

@note The caller is responsible for freeing the returned string, possibly by using FreeString
@see FreeString
*/
char* TopSortKahnString(const char* format_string){
	try{
		std::unordered_map<std::string, std::vector<std::string>> g = Parse(format_string);
		std::vector<std::string> TopOrder = KahnTopSort(g);
		std::string result_str;
		for (size_t i = 0; i < TopOrder.size(); i++){
			result_str += TopOrder[i];
			if (i < TopOrder.size() -1) result_str += ",";
		}
		char* result = new char[result_str.length() + 1];
		strcpy(result, result_str.c_str());
		return result;
	}
	catch(const std::exception& e){
		std::cerr << e.what() << std::endl;
		return nullptr;
	}
}
